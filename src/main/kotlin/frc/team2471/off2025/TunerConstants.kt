package frc.team2471.off2025

import com.ctre.phoenix6.CANBus
import com.ctre.phoenix6.configs.CANcoderConfiguration
import com.ctre.phoenix6.configs.Slot0Configs
import com.ctre.phoenix6.configs.TalonFXConfiguration
import com.ctre.phoenix6.hardware.CANcoder
import com.ctre.phoenix6.signals.StaticFeedforwardSignValue
import com.ctre.phoenix6.swerve.SwerveDrivetrainConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstants
import com.ctre.phoenix6.swerve.SwerveModuleConstantsFactory
import edu.wpi.first.math.geometry.Translation2d
import edu.wpi.first.math.system.plant.DCMotor
import edu.wpi.first.units.measure.Distance
import edu.wpi.first.units.measure.LinearVelocity
import edu.wpi.first.wpilibj.Alert
import edu.wpi.first.wpilibj.Preferences
import frc.team2471.off2025.util.ctre.getMagnetSensorOffset
import frc.team2471.off2025.util.isReal
import frc.team2471.off2025.util.units.asDegrees
import frc.team2471.off2025.util.units.asFeet
import frc.team2471.off2025.util.units.asMeters
import frc.team2471.off2025.util.units.asMetersPerSecond
import frc.team2471.off2025.util.units.asRadiansPerSecond
import frc.team2471.off2025.util.units.asVolts
import frc.team2471.off2025.util.units.degrees
import frc.team2471.off2025.util.units.feetPerSecond
import frc.team2471.off2025.util.units.inches
import frc.team2471.off2025.util.units.meters
import frc.team2471.off2025.util.math.round
import frc.team2471.off2025.util.units.rpm
import frc.team2471.off2025.util.units.volts
import kotlin.math.roundToInt

// Generated by the Tuner X Swerve Project Generator
// https://v6.docs.ctr-electronics.com/en/stable/docs/tuner/tuner-swerve/index.html
object TunerConstants {
    val driveMotor = DCMotor.getKrakenX60Foc(1)!!
    val steerMotor = DCMotor(12.0, 4.05, 275.0, 1.4, 7530.0.rpm.asRadiansPerSecond, 1) //x44

    private const val driveGearRatio = 6.746031746031747
    private const val steerGearRatio = 21.428571428571427
    private const val wheelRadiusInches = 2.0 * 0.950495049505

    // The steer motor uses any SwerveModule.SteerRequestType control request with the
    // output type specified by SwerveModuleConstants.SteerMotorClosedLoopOutput
    private val steerGains: Slot0Configs = Slot0Configs().apply {
        kP = 2.4817 * steerGearRatio
        kI = 0.0
        kD = 0.0
        kS = 0.073174
        kV = 2.6622
        kA = 0.05389
        StaticFeedforwardSign = StaticFeedforwardSignValue.UseClosedLoopSign
    }

    // When using closed-loop control, the drive motor uses the control
    // output type specified by SwerveModuleConstants.DriveMotorClosedLoopOutput
    private val driveGains: Slot0Configs = Slot0Configs().apply {
        kP = 0.135
        kI = 0.0
        kD = 0.0
        kS = 0.15
        kV = 0.087
        kA = 0.00892
    }

    // CAN bus that the devices are located on;
    // All swerve devices must share the same CAN bus
    val driveCANBus: CANBus = CANBus("rio", "./logs/example.hoot")

    // Theoretical free speed (m/s) at 12 V applied output;
    // This needs to be tuned to your individual robot
    val kSpeedAt12Volts: LinearVelocity = (driveMotor.freeSpeedRadPerSec / driveGearRatio * 2.0.inches.asFeet).feetPerSecond * 0.9  //4.73.metersPerSecond

    val drivetrainConstants: SwerveDrivetrainConstants = SwerveDrivetrainConstants().apply {
        CANBusName = driveCANBus.name
        Pigeon2Id = CANSensors.PIGEON
        Pigeon2Configs = null //Leave this null to skip applying Pigeon 2 configs
    }

    private val constantCreator: SwerveModuleConstantsFactory<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> =
        SwerveModuleConstantsFactory<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration>().apply {
            /**
             * Initial configs for the drive/steer motors and encoder, these cannot be null.
             * Some configs will be overwritten; see the withInitialConfigs() API documentation.
             *
             * @see SwerveModuleConstants.withDriveMotorInitialConfigs
             * @see SwerveModuleConstants.withSteerMotorInitialConfigs
             * @see SwerveModuleConstants.withEncoderInitialConfigs
              */
            DriveMotorInitialConfigs = TalonFXConfiguration().apply {
                CurrentLimits.apply {
                    SupplyCurrentLimit = 60.0
                    SupplyCurrentLowerLimit = 35.0
                    SupplyCurrentLowerTime = 1.0
                    SupplyCurrentLimitEnable = true
                }
            }
            SteerMotorInitialConfigs = TalonFXConfiguration().apply {
                CurrentLimits.apply{
                    SupplyCurrentLimit = 35.0
                    SupplyCurrentLimitEnable = true
                }
            }
            EncoderInitialConfigs = CANcoderConfiguration()

            /** Gear ratios for steer and drive motors. The number of motor rotations for 1 wheel rotation */
            DriveMotorGearRatio = driveGearRatio
            SteerMotorGearRatio = steerGearRatio

            /**
             * The ratio at which the drive motor spins when the steer turret spins (driveMotorRotations/SteerRotations)
             * Every 1 rotation of the steer results in [SwerveModuleConstantsFactory.CouplingGearRatio] drive motor turns.
             * Found by wedging an object inside the drive wheel (preventing the wheel from spinning) then
             * measuring the change of the drive motor position when the steer turret is rotated 1 rotation.
             **/
            CouplingGearRatio = 3.5714285714285716

            /**
             * Type of closed loop output: Torque or Voltage
             * This affects the units of [SwerveModuleConstantsFactory.DriveMotorGains] PID gains for the motors.
             */
            DriveMotorClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage
            SteerMotorClosedLoopOutput = SwerveModuleConstants.ClosedLoopOutputType.Voltage

            /** PID and [Slot0Configs] of motors */
            DriveMotorGains = driveGains
            SteerMotorGains = steerGains

            /**
             * The stator current at which the wheels start to slip, in amps.
             * Maximum amount of stator current the drive motors can apply without slippage.
            */
            SlipCurrent = 60.0

            /** The max speed of the robot when driven with 12 volts. m/s */
            SpeedAt12Volts = kSpeedAt12Volts.asMetersPerSecond

            /**
             * Type of motor controller
             * The type of motor used for the drive/steer motor
            */
            DriveMotorType = SwerveModuleConstants.DriveMotorArrangement.TalonFX_Integrated
            SteerMotorType = SwerveModuleConstants.SteerMotorArrangement.TalonFX_Integrated

            /**
             * How to use the CANCoder. (Remote, Fused, or Synced)
             * The remote sensor feedback type to use for the steer motors;
             * When not Pro-licensed, FusedCANcoder/SyncCANcoder automatically falls back to RemoteCANcoder
            */
            // Sync doesn't work in sim
            FeedbackSource = if (isReal) SwerveModuleConstants.SteerFeedbackType.SyncCANcoder else SwerveModuleConstants.SteerFeedbackType.FusedCANcoder

            /** Moment of Inertia. Only used in simulation */
            DriveInertia = 0.025
            SteerInertia = 0.0000000004

            /** Simulated voltage required to overcome friction. Only used in simulation */
            DriveFrictionVoltage = 0.2.volts.asVolts
            SteerFrictionVoltage = 0.2.volts.asVolts

            WheelRadius = wheelRadiusInches.inches.asMeters //<- wheel radius can be overridden during module config
        }

    //Usually swerve drives are square
    val moduleTrackWidth = 12.125.inches

    val frontLeft = ModuleConfig(
        Falcons.FRONT_LEFT_DRIVE,
        Falcons.FRONT_LEFT_STEER,
        CANCoders.FRONT_LEFT,
        driveMotorInverted = false,
        steerMotorInverted = true,
        encoderInverted = false,
        moduleTranslationMeters = Translation2d(moduleTrackWidth, moduleTrackWidth),
        id = 0,
        wheelRadiusOverride = null,
        driveMotorGainsOverride = null
    ).createModuleConstants()

    val frontRight = ModuleConfig(
        Falcons.FRONT_RIGHT_DRIVE,
        Falcons.FRONT_RIGHT_STEER,
        CANCoders.FRONT_RIGHT,
        driveMotorInverted = false,
        steerMotorInverted = true,
        encoderInverted = false,
        moduleTranslationMeters = Translation2d(moduleTrackWidth, -moduleTrackWidth),
        id = 1,
        wheelRadiusOverride = null,
        driveMotorGainsOverride = null
    ).createModuleConstants()

    val backLeft = ModuleConfig(
        Falcons.BACK_LEFT_DRIVE,
        Falcons.BACK_LEFT_STEER,
        CANCoders.BACK_LEFT,
        driveMotorInverted = false,
        steerMotorInverted = true,
        encoderInverted = false,
        moduleTranslationMeters = Translation2d(-moduleTrackWidth, moduleTrackWidth),
        id = 2,
        wheelRadiusOverride = null,
        driveMotorGainsOverride = null
    ).createModuleConstants()

    val backRight = ModuleConfig(
        Falcons.BACK_RIGHT_DRIVE,
        Falcons.BACK_RIGHT_STEER,
        CANCoders.BACK_RIGHT,
        driveMotorInverted = false,
        steerMotorInverted = true,
        encoderInverted = false,
        moduleTranslationMeters = Translation2d(-moduleTrackWidth, -moduleTrackWidth),
        id = 3,
        wheelRadiusOverride = null,
        driveMotorGainsOverride = null
    ).createModuleConstants()


    val moduleConfigs = arrayOf(frontLeft, frontRight, backLeft, backRight)

    init {
        println("TunerConstants created ${moduleConfigs.size} modules.")
    }


    class ModuleConfig(
        val driveMotorID: Int,
        val steerMotorID: Int,
        val canCoderID: Int,
        val driveMotorInverted: Boolean,
        val steerMotorInverted: Boolean,
        val encoderInverted: Boolean,
        val moduleTranslationMeters: Translation2d,
        val id: Int,
        val wheelRadiusOverride: Distance? = null,
        val driveMotorGainsOverride: Slot0Configs? = null,
    ) {
        fun createModuleConstants(): SwerveModuleConstants<TalonFXConfiguration, TalonFXConfiguration, CANcoderConfiguration> {

            val canCoder = CANcoder(canCoderID, driveCANBus.name)
            var magnetSensorOffset = canCoder.getMagnetSensorOffset()

            //Use NT preferences as a backup to check if the encoder offset is valid
            if (canCoder.isConnected) {
                val prefsOffset = Preferences.getDouble("Module $id Offset", Double.NaN).degrees
                if (prefsOffset.asDegrees.isNaN()) {
                    //couldn't find prefs
                    println("Module $id has missing Preferences, setting to encoders Offset: ${magnetSensorOffset.asDegrees.roundToInt()}")
                    Preferences.setDouble("Module $id Offset", magnetSensorOffset.asDegrees)
                    Alert("Module $id had missing offset prefs", Alert.AlertType.kWarning).set(true)
                } else if (prefsOffset.asDegrees.roundToInt() != magnetSensorOffset.asDegrees.roundToInt()) {
                    //offsets are different, default to prefs
                    println("Module $id has conflicting offsets. prefsOffset: ${prefsOffset.asDegrees.round(2)} encoders Offset: ${magnetSensorOffset.asDegrees.round(2)}")
                    magnetSensorOffset = prefsOffset
                    Alert("Module $id had conflicting encoder offsets", Alert.AlertType.kWarning).set(true)
                }
            } else {
                Alert("Module $id CANCoder Disconnected On INIT", Alert.AlertType.kError).set(true)
            }


            return constantCreator.createModuleConstants(
                steerMotorID,
                driveMotorID,
                canCoderID,
                magnetSensorOffset,
                moduleTranslationMeters.x.meters,
                moduleTranslationMeters.y.meters,
                driveMotorInverted,
                steerMotorInverted,
                encoderInverted
            ).apply {
                if (driveMotorGainsOverride != null) DriveMotorGains = driveMotorGainsOverride
                if (wheelRadiusOverride != null) WheelRadius = wheelRadiusOverride.asMeters
            }
        }
    }
}